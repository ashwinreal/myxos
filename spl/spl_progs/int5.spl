alias phySP S0;
phySP = (SP%512) + ([PTBR + 2*(SP/512)]*512);
alias syscallno S1;
syscallno = [phySP-1];
alias ctr S2;
alias childpcbno S4;
///// Fork
//print("int 5");	
alias ctr2 S7;
if(syscallno==8) then
	//print("in fork");
	ctr=0;
	while(ctr<32)  do  // check PCB space available
		if([1536 + 32*ctr + 1] == 0) then    //state = 0 then free 
			break;
		endif;
		ctr=ctr+1;
	endwhile;
	if(ctr==32) then
		print("nopcb");
		[phySP-2]=-1;
		ireturn;
	endif;
	
	childpcbno = ctr;

	[1536 + 32*childpcbno + 0] = childpcbno; // setting pid 
	//print(childpcbno);



//----------------------------------------
	//step 4 deleted
//---------------------------------



	ctr=0;
	ctr2=0;
	while(ctr<64) do 
		if([1280 + ctr]==0) then
			break;
		endif;
		ctr=ctr+1;
	endwhile;

	if(ctr==64) then                     //note:If a free page for stack is not available, some page can be swapped to the disk to make space 
		print("no stack");
		[phySP-2]=-1;
		ireturn;
	endif;

	[1280 + ctr]=1; //stack used
	//print ("stack=");
	//print ctr;
	ctr2=0;
	while(ctr2<512) do //copy stack word to word
		[512*ctr + ctr2]= [[PTBR + 2*3]*512 + ctr2];   // if implementing above note then change this also cos stack may not be present
		ctr2=ctr2+1;
	endwhile;

	[1024 + 8*childpcbno + 3*2] = ctr; // setting page for stack
	[1024 + 8*childpcbno + 3*2 + 1] = "01";

	ctr=0;
	while(ctr<=2) do // copy page table except stack
		[1024 + 8*childpcbno + 2*ctr ]=[PTBR + 2*ctr];
		[1024 + 8*childpcbno + 2*ctr + 1]=[PTBR + 2*ctr + 1];

		if([PTBR + 2*ctr + 1] == "01" || [PTBR + 2*ctr + 1] == "11") then
			[1280 + [PTBR + 2*ctr]]= 1 + [1280 + [PTBR + 2*ctr]] ;
		else if( [PTBR + 2*ctr] >=448) then
				[6*512 + [PTBR + 2*ctr]] = 1 + [6*512 + [PTBR + 2*ctr]];   // increase the swap area shared pages count
			endif;

		endif;

		ctr=ctr+1;

	endwhile;














	[1536 + 32*childpcbno + 5]=1024 + 8*childpcbno; //set PTBR in pcb
	[1536 + 32*childpcbno + 4] = [phySP] ;// setting the IP ,note: only physical add. is dif. bt logical is same 
	[1536 + 32*childpcbno + 3]=SP-1; 

	alias ppid S9;
	ppid=(PTBR-1024)/8;

	[1536 + 32*childpcbno +2]=BP; //BP


	[1536 + 32*childpcbno +6]=PTLR;//PTLR
	[1536 + 32*childpcbno +7]=R0; //R0
	[1536 + 32*childpcbno +8]=R1;
	[1536 + 32*childpcbno +9]=R2;
	[1536 + 32*childpcbno +10]=R3;
	[1536 + 32*childpcbno +11]=R4;
	[1536 + 32*childpcbno +12]=R5;
	[1536 + 32*childpcbno +13]=R6;
	[1536 + 32*childpcbno +14]=R7;


	ctr=15;
	
	alias temp S14;
	//print("here");
	while(ctr<31) do
		[1536 + 32*childpcbno +ctr]=[1536 + 32*ppid + ctr];
		//print(ctr);
		//print([1536 + 32*ppid + ctr]);
		if(ctr%2==1 && [1536 + 32*ppid+ ctr]!=-1) then
			print("in if");
			temp=[1536 + 32*ppid + ctr];
			print(temp);
			[FILE_TABLE + [1536 + 32*ppid + ctr] +1]=1+[FILE_TABLE + [1536 + 32*ppid + ctr] +1]; //in file open cnt if open
			print("out if");
		endif;
		ctr=ctr+1;

	endwhile;
	[1536 + 32*childpcbno +1]=1;  // ready state

	[phySP-2]=childpcbno; //return child pid to the parent !!!!!!

	[1536 + 32*childpcbno +31]=[READY_LIST + ((PTBR-1024)/8)*32 + 0]; // for getppid !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


	phySP = ((SP-1)%512) + ([(1024 + 8*childpcbno) + 2*((SP-1)/512)]*512); //return -2 to child
	//print(phySP);
	[phySP-1]=-2; // return -2 to the child

	//print("child..");
	//print([1536 + 32*childpcbno + 4] );
	//print("forked");
	ctr=0;
//	[phySP]=[1536 + 32*childpcbno + 4];

	ctr=0;

	ctr=0;
	//print(childpcbno);
	while(ctr<32) do
		//print([1536 + 32*childpcbno + ctr]);
		ctr=ctr+1;
	endwhile;
	ctr=0;
	while(ctr<32) do
		//print([1536 + 32*ppid + ctr]);
		ctr=ctr+1;
	endwhile;
	breakpoint;
	ireturn;


endif;