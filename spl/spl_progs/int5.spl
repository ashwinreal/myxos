alias phySP S0;
phySP = (SP%512) + ([PTBR + 2*(SP/512)]*512);
alias syscallno S1;
syscallno = [phySP-1];
alias ctr S2;

///// Fork
//print("int 5");

if(syscallno==8) then
	print("in fork");
	ctr=0;
	while(ctr<32)  do  // check PCB space available
		if([1536 + 32*ctr + 1] == 0) then    //state = 0 then free 
			break;
		endif;
		ctr=ctr+1;
	endwhile;
	if(ctr==32) then
		print("nopcb");
		[phySP-2]=-1;
		ireturn;
	endif;
	alias childpcbno S4;
	childpcbno = ctr;

	[1536 + 32*childpcbno + 0] = childpcbno; // setting pid 
	//print(childpcbno);

	ctr=0;
	alias ctr2 S5;
	ctr2=0;
	while(ctr<4) do            //checking no of valid pages in pg table
		//print([PTBR + 2*ctr + 1]);
		if([PTBR +2*ctr ]!=-1 &&([PTBR + ctr*2 +1]=="01" || [PTBR + ctr*2 + 1]=="11")) then
			//print([PTBR +2*ctr ]);
			ctr2=ctr2+1;
		endif;
		ctr=ctr+1;
	endwhile;

	alias vpgs S6; 
	vpgs=ctr2;

	ctr=0;
	while(ctr<64) do // checking if ctr2 memory pages are avail. in memory list
		if(ctr2==0) then 
			break;
		endif;
		if([1280 + ctr]==0) then
			ctr2=ctr2-1;
		endif;
		ctr=ctr+1;	
	endwhile;

	if(ctr2!=0) then        // no mem pages avail.
		print("pagesfull");
		[phySP-2]=-1;
		ireturn;
	endif;

	ctr=0;
	ctr2=0;
	alias ctr3 S8;

	
	while(ctr<64) do // free pages are avail.!! so update the memfree list,copy the parent page for child,update child page table 
		if(ctr2==vpgs)then
			break;
		endif;
		if([1280 + ctr]==0) then
			//print("..");
			//print(ctr);
			[1280 + ctr]=1;  //mark mem page used
			ctr3=0;
			//print([PTBR  + 2*ctr2 + 0 ]);
			while(ctr3<512) do
				
				[512*ctr + ctr3]=[512*([PTBR  + 2*ctr2 + 0 ]) +ctr3]; //copy pages
				ctr3=ctr3+1;
			endwhile;

			[1024 + 8*childpcbno + ctr2*2]=ctr;              //childpcbno==pid
			[1024 + 8*childpcbno + ctr2*2 +1]=[PTBR + ctr2*2 + 1]; 

			ctr2=ctr2+1;
		endif;
		ctr=ctr+1;
	endwhile;

	[1536 + 32*childpcbno + 5]=1024 + 8*childpcbno; //set PTBR in pcb
	[1536 + 32*childpcbno + 4] = [phySP] ;// setting the IP ,note: only physical add. is dif. bt logical is same 
	[1536 + 32*childpcbno + 3]=SP-1; 

	alias ppid S9;
	ppid=(PTBR-1024)/8;

	[1536 + 32*childpcbno +2]=BP; //BP


	[1536 + 32*childpcbno +6]=PTLR;//PTLR
	[1536 + 32*childpcbno +7]=R0; //R0
	[1536 + 32*childpcbno +8]=R1;
	[1536 + 32*childpcbno +9]=R2;
	[1536 + 32*childpcbno +10]=R3;
	[1536 + 32*childpcbno +11]=R4;
	[1536 + 32*childpcbno +12]=R5;
	[1536 + 32*childpcbno +13]=R6;
	[1536 + 32*childpcbno +14]=R7;


	ctr=15;
	
	alias temp S14;
	//print("here");
	while(ctr<31) do
		[1536 + 32*childpcbno +ctr]=[1536 + 32*ppid + ctr];
		//print(ctr);
		//print([1536 + 32*ppid + ctr]);
		if(ctr%2==1 && [1536 + 32*ppid+ ctr]!=-1) then
			print("in if");
			temp=[1536 + 32*ppid + ctr];
			print(temp);
			[FILE_TABLE + [1536 + 32*ppid + ctr] +1]=1+[FILE_TABLE + [1536 + 32*ppid + ctr] +1]; //in file open cnt if open
			print("out if");
		endif;
		ctr=ctr+1;

	endwhile;
	[1536 + 32*childpcbno +1]=1;  // ready state

	[phySP-2]=childpcbno; //return child pid to the parent !!!!!!

	[1536 + 32*childpcbno +31]=[READY_LIST + ((PTBR-1024)/8)*32 + 0]; // for getppid !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


	phySP = ((SP-1)%512) + ([(1024 + 8*childpcbno) + 2*((SP-1)/512)]*512); //return -2 to child
	//print(phySP);
	[phySP-1]=-2; // return -2 to the child

	//print("child..");
	//print([1536 + 32*childpcbno + 4] );
	print("forked");
	ctr=0;
//	[phySP]=[1536 + 32*childpcbno + 4];

	ctr=0;

	ctr=0;
	print(childpcbno);
	while(ctr<32) do
		//print([1536 + 32*childpcbno + ctr]);
		ctr=ctr+1;
	endwhile;
	ctr=0;
	while(ctr<32) do
		//print([1536 + 32*ppid + ctr]);
		ctr=ctr+1;
	endwhile;
	ireturn;


endif;